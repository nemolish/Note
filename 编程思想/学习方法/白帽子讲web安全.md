### 白帽子讲web安全

[TOC]

#### 第一篇 世界观安全
##### 第一章 安全原则
* secure by default原则
    开放最基本的功能，其他功能都关闭，例如白名单思想、最小权限
* 纵深防御原则
    多层次多维度实施安全方案、在正确的地方做正确的事情
* 数据和代码分离原则
    将数据和代码分离开来，避免在将数据当做代码来使用时，数据被注入了不安全的代码
    这个原则广泛适用于各种基于“注入”的攻击
* 不可预测性原则
    避免被猜测到关键数据、提高攻击成本
    
#### 第二篇 客户端脚本安全 
##### 第二章  浏览器安全
2.1 同源策略
浏览器同源策略限制了来自不同源的“document”或者脚本对当前“document”读取或者设置某些属性

同源指：同域名或者IP、子域名（二级域名）、端口、协议

另外，关于js的同源，例如在a.com上通过

```html
<script src=http://b.com/b.js></script>
```

加载了b.js，b.js的来源是b.com，但运行b.js的是a.com，因此相对于当前页面（a.com）来说，b.js的源（Origin）是a.com而不是b.com。

`<script>`、`<img>`、`<iframe>`、`<link>`与及style中的background：url("")等标签可以跨域加载资源而不
受同源策略的限制。

注意：style中的background：url("")也能引入js，如

```html
<div style="background：url('javascript:alert(1)')">
```

2.2 浏览器沙箱
多进程将浏览器各个部件分离开来

2.3恶意网站拦截
浏览器基于黑名单警告用户访问的网址不安全

##### 第三章 跨站脚本攻击（cross site script XSS）

黑客通过“HTML注入”篡改了网页，插入了恶意的脚本，从而在用户访问网页时脚本执行了非法操作

3.1 xss攻击的能做些什么
相对于注入js代码，xss有个更高效的注入方式，即注入`<script>`标签，通过script标签引入js脚本文件，这种方法被称为xss payload

3.1.1 xss进行cookie劫持（窃取用户cookie）、在攻击目标网页上构造GET与POST请求

构造请求的方法有二：1.创建一个form表单并提交；2.通过XMLHttpRequest发送请求（ajax）

3.1.2 xss钓鱼  通过跨站脚本构造浏览器的交互页面，如创建一个伪造的登录框等来骗取用户的敏感数据，并将数据发送到黑客的服务器上。

3.1.3 识别用户浏览器  获取用户的浏览器和操作系统信息，针对性地根据系统和浏览器漏洞发动内存攻击。

3.1.4 识别用户安装的软件，如ie可以通过判断ActiveX控件的classid是否存在来推测用户是否安装了该软件，然后针对该软件达到植入木马的目的（如迅雷控件、flash插件、浏览器扩展等）

3.1.5 CSS history hack  通过css hack获取用户访问过哪些网站。其原理是利用style的visited属性——如果用户访问过某个链接，那么这个链接的颜色会变得与众不同。

3.1.6 获取用户的真实ip地址  由于NAT或者用户使用了代理，网站不到用户客户端的内网IP，这时可以通过java aplet（如果用户安装了jre的话）获取到客户端的本地IP（参考Attack API框架，这是个xss攻击框架）

3.2 xss攻击框架
3.2.1 attack api
3.2.2 BeFF
3.2.3 终极武器 XSS Worm

3.3 XSS防御
本质上html注入是因为用户的输入数据被当做代码进行执行，从而混淆了原本的语义，产生新的语义。
防御方法则是对用户输入进行转码，在无法转码的地方则对用户的输入进行关键字检查。
另外，在富文本输入的场景中，限定只使用某几种安全的标签（标签白名单），并限制标签中跟js相关的属性，如onclick等。

##### 第四章 跨站请求伪造（CSRF）

CSRF攻击是攻击者利用用户身份操作用户账户的一种攻击方式。

4.1 CSRF的防御

4.1.1 验证码：在发送请求前强制与用户进行交互，但这种方式只能提高攻击的成本，还是可以破解的，不如将验证码图片回发给攻击者，攻击者手动破解。同时这种方式会影响用户体验，所以只能作为辅助手段。

4.1.2 referer check：常见的防止"图片盗链接"的手段，同理，检查用户的请求来源可以防御一部分CSRF，比如某些用户操作的表单请求的referer必然是这个表单所在的页面。如果不是，甚至都不是这个页面所在的域，则极有可能是CSRF攻击。但注意，某些情况下，如https跳转到http，出于安全考虑，浏览器不会发送referer。

4.1.3 Anti CSRF Token
原理：CSRF的本质原因是重要操作的所有参数都被攻击者获取到。Anti CSRF Token则破坏这个前提。比如把参数加密或者使用一些随机数让攻击者无法猜测、获取到这个参数。这是安全原则中"不可预测性原则"的一种应用。

参数加密的问题：1.url难读，如果是变化的url，则这个url无法被收藏；2.增加数据分析的难度；

使用Anti CSRF Token
在参数中增加一个token参数，token必须足够随机，足够安全，或者采用真随机数生成器。token不应该被窃取，具有保密性；token应该具有时效性；

CSRF仅仅用于对抗CSRF攻击，但当网站存在XSS漏洞时，这个安全策略会变得无效，XSS可以直接在用户的客户端模拟请求。
XSS带来的问题应该由XSS的防御方案予以解决，否则CSRF的Token防御就是空谈。
安全防御的体系是相辅相成、缺一不可的。

##### 第五章 点击劫持（ClickJacking）
原理：略
防御手段：X -Frame-Option
一下浏览器支持X -Frame-Option 
IE8＋
Opera10.50＋
Safaru4＋
Chrome 4.1＋
Firefox3.6.9＋

X -Frame-Option 的选项
DENY 浏览器拒绝为当前页面加载任何frame
SAMEORIGIN frame页面的地址只能为同源域名下的页面
ALLOW－FROM origin 制定允许frame加载的页面地址

#### 第三篇 服务器端应用安全

##### 第九章 认证与回话管理

SessionID在生命周期内被窃取等同于账户失窃
如果SessionID存在cookie中，有多种方式窃取SessionID，如XSS、本地木马、网络Sniff（嗅探）

可能被利用的漏洞：
固定sessionID的 Session Fixation攻击
当用户打开未认证的网页，进行认证后继续沿用旧的sessionID，只是在后台上设置了session的状态。如果用户的sessionID在登陆前就被获取了，比如：sessionId来源于URL的sid，而这个URL是黑客提供的，那么这个sessionID就是不安全的。黑客可以通过这个sessionID登陆认证后的账号。

##### 第十章 访问控制
抽象地说，访问控制（也叫权限控制），都是主题（subject）对某个客体（object）需要实施某种操作（operation），而系统对这种操作的限制就是权限控制。

10.1
web应用中根据访问客体的不同，常见的访问控制可以分为
1)  基于URL的访问控制
2)  基于方法的访问控制
3)  基于数据的访问控制

10.2 垂直权限管理：将用户归属到一个角色中，然后将权限的集合与角色对应起来，这种方法称为基于角色的访问控制（Role-Based Access Control），简称RBAC。这就是垂直权限管理的方式。
用户－角色－权限

Spring Security中的权限管理就是RBAC模型的一个实现，它基于Spring MVC框架，提供了两种访问控制实现：基于URL的访问控制和基于方法（method）的访问控制。

10.3 水平权限：基于数据的权限访问控制方式
例如在系统中，a用户越权访问了只属于b用户的数据，这种情况是不允许的。越权访问数据的问题我们称之为"水平权限管理问题"。然而，对数据的权限控制与系统业务结合得非常紧密，目前没有统一的框架解决这个问题。另外，当数据涉及跨表、跨库，最好提前设计相应的权限控制规则，否则在项目上线后再改动，对系统的改动会比较大，并且有可能影响到性能。

10.4 OAuth 
OAuth 是一个在不提供用户名和密码的情况下，授权第三方应用访问web资源的安全协议。
OAuth与互联网开放SSO系统（如微博登录系统、OpenID）都致力于让互联网变得更加开放。互联网开放SSO系统解决的是认证问题，而OAuth钢架注重授权。认证和授权的关系其实是一脉相承的，后来人们发现，其实更多的时候 真正需要的是对资源的授权


第十一章  加密算法与随机数

11.1 概述
加密算法通常分为分组加密算法流密码加密算法，两者的实现原理不同。
分组加密算法的代表有：DES，3-DES，Blowfish、IDEA、AES等；
流密码加密算法的代表有：RC4、ORYX、SEAL等；

针对加密算法的攻击，一般根据攻击者获得的信息，可分为：
11.1.1唯密文攻击
攻击者只有一些密文，它们是使用同一加密算法和同一密钥加密的，这种攻击是最难的。
11.1.2 已知明文攻击
攻击者除了得到一些密文外，还能得到这些密文对应的明文
11.1.3选择明文攻击
攻击者不仅能得到一些密文和明文，还能选择用语加密的明文。
11.1.4选择密文攻击。


11.6 密钥管理
密码学里有个基本原则：密码系统的安全性应该依赖于密钥的复杂性，而不应该依赖于算法的保密性。
密钥管理中最常见的错误就是将密钥硬编码在代码里。
通常正确的做法是保存在配置文件或者数据库中。

11.7 伪随机数问题
伪随机数问题——伪随机数不够随机，是程序开发中会出现的一个问题。
伪随机数问题的攻击方式在多数情况下都只存在于理论中，难以证明。但伪随机数的问题是真实存在的、不可忽视的一个安全问题。

伪随机数 是通过数学算法生成的随机数，并非真正的随机数。密码学上的安全伪随机数应该是不可压缩的。对应的"真随机数"，则是通过一些物理系统生成的随机数，比如电压的波动、磁盘磁头寻道时间、空中电磁波的噪声等。

实例：使用pid作为随机因子，而linux中pid最大值是32768，这个是可以被遍历等；另外如使用时间作为随机因子，若攻击者可以获得系统时间，那么这个随机因子很容易被猜到。

对于伪随机数问题，我们要谨记：在重要敏感的系统中，一定要使用足够强壮的随机数生成算法。
在java中可以使用java.security.SecureRandom；
在linux中，可以使用/dev/random  或者 /dev/urandom来生成随机数，只需要读取即可；
此外，从算法上还可以通过多个随机数的组合，以增加随机数的复杂性。如对因子进行MD5后，加上一个随机数再MD5一次。

11.8 小结
加密算法的选择和使用上有以下最佳实践：
1）不要使用ECB（电码簿）模式
2）不要使用流密码
3）不要使用相同的key做不同 的事情
4）salts与IV需要随机产生
5）使用HMAC-SHA1代替MD5（甚至代替SHA1）
6）不要自己实现加密算法，尽量使用安全专家已经实现好的库
7）不要依赖系统的保密性
当你不知道该如何选择时，有以下建议：
1）使用CBC模式的AES256用于加密
2）使用HMAC-SHA512用于完整性检查
3）使用带salt的SHA-256或者SHA-512用于Hashing 

第十三章 拒绝服务攻击

13.1 DDOS简介
DDOS 拒绝服务攻击有以下类型
13.1.1 网络层DDOS 
如SYN flood、UDP flood、 ICMP flood
SYN flood利用了TCP协议的缺陷，它的攻击方式是伪造大量的源IP地址并向服务器发送TCP连接请求，在TCP三次握手中不返回第三次响应。此时服务端则会维持住TCP连接并重试发送第二次响应报文，当维持的连接数大到一定程度则无法响应正常的网络请求。

13.1.2应用层DDOS
针对web应用程序本身的攻击，如CC攻击，发送大量网络请求，使web应用程序忙于处理这些请求而无法响应正常的网络请求。

防御方式
频率限制：在应用程序中针对每个"客户端"做一个请求频率限制；
验证码：利用与用户的交互来过滤DDOS脚本的请求
客户端合法性判断：过滤非合法客户端的请求，如根据user－agent判断客户端（可伪造，不过不失为一种方式），另一种可靠的方式是让客户端执行一段js脚本，可以判断请求是否来自浏览器，这可以过滤一部分python脚本之类的请求，当然，有些ddos脚本本身就是运行在浏览器环境中的js脚本，这种就无法防御。

13.1.3 资源耗尽攻击
利用web Server的漏洞或者设计缺陷进行攻击，如果web server的http连接数有限，攻击者以极低的速度发送http请求的请求体，等到耗尽http的连接数，web server将无法再接受新的请求，导致拒绝服务攻击。

13.1.4 正则表达式DDOS
正则表达式匹配的效率比较低，在匹配字符串长度线性增长时，匹配的消耗时间成指数级增长，这点有可能被攻击者利用来耗尽web应用的资源，造成拒绝服务攻击的目的。
